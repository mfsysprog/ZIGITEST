/* rexx */
   top
   NUM_RUNS = 20
   localrep = ''
   zigirep = 'tmp'
   encoding = 'ibm-1047'
   ver = 'zigitag'

   say 'We will run ex in bpxwunit and spawn each 'NUM_RUNS' times.'

   call syscalls 'ON'
/* syscall will be our default host environment */
   address syscall

   cmd = 'ls' localrep'/'zigirep'/.gitattributes'
   x = bpxwunix(cmd,,so.,se.)
    /* lets remove it for now */
   if so.0 = 1 then
   'unlink 'localrep'/'zigirep'/.gitattributes'

/* do the init call to our ccsidtocs routine */
   say 'Triggering build of ccsid to code set name translation table.'
   call ccsidtocs

   path = localrep"/"zigirep"/.gitattributes"
   'open' path,
     O_rdwr+O_creat+O_trunc,
     660
   if retval = -1 then exit 8
   fd = retval  /* as I think it's weird to write to a retval lol */

/* setup_iconv will prepare a iconv spawn syscall                 */

   call setup_iconv

/* we replace the default pipe write end of iconv_stdout.2 with */
/* the fd filedescriptor, so our iconv we spawn next will write */
/* directly to the file we opened before which has fd as its    */
/* file descriptor                                              */
/* just as a test to see if we can have a generic setup for     */
/* iconv that we can 'bend' later                               */
   'dup2' fd iconv_stdout.2

   'spawn /bin/iconv 'parms.0' map. parms. env.'
   pid = retval

/* for this write we want to write to the stdin for the iconv process */
   fd_out = iconv_stdin.2
   call write ,
     "# This .gitattributes file is autogenerated with zigi" ver
   call write ,
     "*   git-encoding=iso8859-1 zos-working-tree-encoding="encoding
   ga3a = ".gitattributes    "
   ga3b = "git-encoding=iso8859-1 zos-working-tree-encoding=iso8859-1"
   ga3  = ga3a || ga3b
   call write ga3
   ga4a = ".gitignore        "
   ga4b = "git-encoding=iso8859-1 zos-working-tree-encoding=iso8859-1"
   ga4  = ga4a || ga4b
   call write ga4
   binaries = '*.docm *.docx *.doc *.dotx *.pdf *.epub *.mobi *.azw3' ,
     '*.jpg *.jpeg *.png *.gif *.zip *.gzip *.tz *.z *.Z *.pax' ,
     '*.ppt *.pptx *.xls *.xlsx *.xlsm *.obj *.bin'
   do gai = 1 to words(binaries)
      ga = word(binaries,gai) 'binary'
      call write ga
   end
/* closing the write end of the iconv_stdin will act as EOF */
   'close' iconv_stdin.2


/* tag it and bag it */
   cmd = 'cd 'localrep'/'zigirep' && '
   cmd = cmd 'chtag -tc iso8859-1 .gitattributes'
   x = bpxwunix(cmd,,so.,se.)

/* this does require autoconvert to be on */
/* we use the same env for bpxwunix and syscall for honest compare */
   env.0 = 2
   env.1 = "_BPXK_AUTOCVT=ON"
   env.2 = "_BPX_SHAREAS=MUST"

   x = time('e')

/* lets see if we can remove this string from our file */
   remove_string = '*.mobi binary'

/* this uses the ex command to do a g(lobal) d(elete) of the remove_string */
/* after which we w(rite) and q(uit).                                      */
/* perhaps sed -i would have been nicer, but omvs doesn't have the -i flag */
   do i = 1 to NUM_RUNS
   cmd = 'ex -s +"g/'remove_string'/d|w|q" 'localrep'/'zigirep'/.gitattributes'
      x = bpxwunix(cmd,,so.,se.,env.)
   end

   say 'the bpxunix ex took: ' time('r')

/* and now for the syscall version */
/* lets see if we can remove another string from this file */
   remove_string = '*.gif binary'

   parms.0 = 4
   parms.1 = '/bin/ex'
   parms.2 = '-s'
   /* please note that we must *not* use the " " here */
   parms.3 = '+g/'remove_string'/d|w|q'
   parms.4 = localrep'/'zigirep'/.gitattributes'
   maps.0 = -1
   maps.1 = -1
   maps.2 = -1
/* getting errors from last syscall:
   "strerror" errno errnojr "err."
   do i = 1 to err.0
      say err.i
   end
*/
   do i = 1 to NUM_RUNS
      'spawn /bin/ex 3 maps. parms. env.'
   /* wait for /bin/ex to finish processing */
      'waitpid' retval 'stemmie. 0'
   end

   say 'the syscall ex took: ' time('e')

/* lets check the autoconversion for .gitattributes at this point */
   y = ccsidtocs(check_autoconversion(fd))
   say 'file is 'y

   'close' fd

   call syscalls 'OFF'

/* Create the .zigi folder in the repo and add the dsn-file */
   cmd = 'cd 'localrep'/'zigirep' && mkdir .zigi'
   x = bpxwunix(cmd,,so.se.)

/* Fill dsn file with the comments */
   path = localrep"/"zigirep"/.zigi/dsn"
   'open' path,
     O_rdwr+O_creat+O_trunc,
     660
   if retval = -1 then do
      Address ISPExec
      zs1 = "Something bad when creating .zigi/dsn."
      zs4 = 'Press F3 to close this popup and exit.'
      parse value '' with zs2 zs3
      call do_popup4
      return
   end
   fd = retval  /* as I think it's weird to write to a retval lol */
/* for this write we want to write to the fd directly */
   fd_out = fd
   call write "# zigi dsn-file"
   call write "# This file needs to be here."
   call write "# Don't edit unless you know what you're doing :)"
   call write '#  '
   call write '# record format is (case insensitive):'
   call write '#  '
   call write '# Position - description'
   call write '#  '
   call write '# 1 - directory name which will be prefixed by the'
   call write '#     defined HLQ to create the z/OS dataset'
   call write '#     (* defines the default)'
   call write '# 2 - PS or PO (dataset organization)'
   call write '#     PS for a flat file'
   call write '#     PO for a directory and thus a partitioned dataset'
   call write '# 3 - record format (FB or VB)'
   call write '# 4 - lrecl'
   call write '# 5 - blksize'
   call write '#     0 is allowed if system determined blksize is enabled'
   call write '# 6 - extension (optional - if used then no period)'
   call write '#     file extension to be used for PDS members in USS'
   call write '#  '
   call write '# Default DSORG and DCB info'
   call write '* PO FB 80 32720'
   'close' fd
   exit 0

setup_iconv:
  /* first create some pipes for our iconv process */
   address syscall "pipe iconv_stdin."
   address syscall "pipe iconv_stdout."
   address syscall "pipe iconv_stderr."
  /* set environment */
   env.0 = 2
   env.1 = "_BPX_SHAREAS=MUST"
   env.2 = "_BPX_SPAWN_SCRIPT=YES"
  /* map our pipes for iconv process */
  /* each pipe has a read end (the .1 stem) and a write end (the .2 stem) */
  /* so the stdin for iconv (map.0) will read for iconv_stdin */
  /* and will write to fd and possibly iconv_stderr */
   map.0 = iconv_stdin.1
   map.1 = iconv_stdout.2
   map.2 = iconv_stderr.2
  /* iconv has 5 parms, the first being the command itself */
   parms.0 = 5
   parms.1 = "iconv"
   parms.2 = "-f"
   parms.3 = "ibm-1047"
   parms.4 = "-t"
   parms.5 = "iso8859-1"
   return

write:
   parse arg string
   string = string || ESC_R || ESC_N
   'write' fd_out 'string' length(string)
   return

/* this checks for autocvt setting in bpxparm                         */
/* use SETOMVS AUTOCVT=OFF, SETOMVS AUTOCVT=ON or SETOMVS AUTOCVT=ALL */
/* to see its effect. But only on a sandbox system, since you will    */
/* set it for all omvs. Using the same call it is possible to set     */
/* autocvt for the file associated with fd by setting cmd to          */
/* CVT_SETCVTOFF, CVT_SETCVTON, CVT_SETCVTALL or CVT_SETAUTOCVTON,    */
/* CVT_SETAUTOCVTALL. See the books for the difference.               */
/* many commands can set env. var which can specify _BPXK_AUTOCVT to  */
/* do it on a lower level than for the whole omvs environment,        */
/* but safest option would be to use cmd CVT_SETCVTON to force it on  */
/* for this fd.                                                       */
/* For EBCDIC (1047) the CCSID is '0417'X; for ASCII (819) it is '0333'X */
check_autoconversion:
   arg ccsid_fd
   pccsid = '0000'x
   fccsid = '0000'x
   cmd = cvt_querycvt
   "f_control_cvt ("ccsid_fd") cmd pccsid fccsid"
/* cmd should have autoconversion status  */
   if cmd = CVT_SETCVTOFF then say 'Autoconversion off'
   if cmd = CVT_SETCVTON then say 'Autoconversion on'
   if cmd = CVT_SETCVTALL then say 'Autoconversion all'
   say 'running program ccsid: 'c2x(pccsid)
   say 'fccsid: 'c2x(fccsid)
   return x2d(c2x(fccsid))

/* this routines converts a ccsid to its code set name */
/* much like the c routine from libiconv.a             */
/* but we parse the iconv -l output                    */
ccsidtocs:
   arg ccsid_in
/* first call we initialize a iconv -l which will take some time */
   if conversion.0 = 'CONVERSION.0' & ccsid_pid = 'CCSID_PID' then do
      'pipe ccsid_stdout.'
      ccsid_env.0 = 2
      ccsid_env.1 = '_BPX_SHAREAS=MUST'
      ccsid_env.2 = '_BPX_SPAWN_SCRIPT=YES'
      ccsid_parms.0 = 2
      ccsid_parms.1 = '/bin/iconv'
      ccsid_parms.2 = '-l'
      ccsid_map.0 = -1
      ccsid_map.1 = ccsid_stdout.2
      ccsid_map.2 = -1
      'spawn /bin/iconv 3 ccsid_map. ccsid_parms. ccsid_env.'
      ccsid_pid = retval
      return
   end
/* on second call we fill the conversion. stem */
   if ccsid_pid <> -1 then do
      'waitpid 'ccsid_pid' stemmie. 0'
      'close 'ccsid_stdout.2
      retval = 1
      do while retval > 0
         'read 'ccsid_stdout.1' regel 100000'
         do while regel <> ''
            parse var regel single '15'x regel
            parse var single '05'x ccsid '05'x name '05'x
            conversion.ccsid = name
         end
      end
      conversion.0 = 'untagged'
      ccsid_pid = -1
   end
/* on 2nd and subsequent calls we answer */
   if ccsid_in <> '' then
   return conversion.ccsid_in
